# Logic Gate Simulator - LLM Context

## Project Overview

This is an interactive web-based logic gate simulator built with **SolidJS**, **TypeScript**, and **Vite**. Users can create digital logic circuits by adding switches, gates, and lights, connecting them with wires, and watching signals propagate in real-time. The application supports touch devices with pan/zoom gestures and includes import/export functionality for saving circuits as JSON.

## Tech Stack

- **Framework**: SolidJS (fine-grained reactive framework)
- **Language**: TypeScript
- **Build Tool**: Vite
- **Styling**: Vanilla CSS (App.css)
- **Graphics**: SVG for all circuit rendering

## Architecture Patterns

### State Management
- **Single Store Pattern**: All circuit state lives in `src/store/circuitStore.ts`
- Uses SolidJS `createStore` for reactive state management
- Store contains: nodes (switches, gates, lights), wires, drag state, canvas state (pan/zoom)
- All mutations happen through store methods (addNode, removeNode, addWire, etc.)

### Component Structure
- **Functional Components**: All components are SolidJS functional components
- **Props Interface**: Each component has a typed Props interface
- **No Class Components**: Use functional patterns only

### Data Flow
1. User interaction → Component event handler
2. Event handler → Store method call
3. Store updates → Automatic re-render (SolidJS reactivity)
4. For circuit changes → `propagateSignals()` computes new output states

## Key Concepts

### Nodes
Three types of nodes (defined in `src/types/circuit.ts`):
- **SwitchNode**: Input component with 1 output port
- **GateNode**: Logic gate with 1-2 input ports, 1 output port (types: AND, OR, NOT, NAND, NOR, XOR, XNOR)
- **LightNode**: Output component with 1 input port

### Ports
- Each node has ports (connection points)
- Ports have unique IDs, type (input/output), and position
- Ports are clickable for wire creation

### Wires
- Connect an output port to an input port
- Store both port IDs and node IDs for efficient lookups
- Each input port can have only ONE incoming wire (enforced)
- Output ports can have multiple outgoing wires

### Signal Propagation
- Iterative algorithm (not recursive) - max 100 iterations
- Starts from switches (primary inputs)
- Propagates through gates using topological evaluation
- Updates light states based on final signal values
- Triggered after any circuit change (toggle switch, add/remove wire)

## Code Conventions

### TypeScript
- All files use TypeScript with strict typing
- No `any` types unless absolutely necessary
- Export types from `src/types/circuit.ts`
- Use type imports: `import type { Circuit } from '../types/circuit'`

### Component Files
- One component per file
- Export component as named export
- Props interface defined above component
- Component file structure:
  ```typescript
  import statements

  interface ComponentProps {
    // props
  }

  export const Component: Component<ComponentProps> = (props) => {
    // component logic
    return <div>...</div>;
  };
  ```

### Naming Conventions
- Components: PascalCase (e.g., `Canvas`, `Switch`)
- Functions/variables: camelCase (e.g., `handleClick`, `nodeId`)
- Types/Interfaces: PascalCase (e.g., `CircuitNode`, `WireDrawState`)
- CSS classes: kebab-case (e.g., `toolbar-btn`, `gate-and`)

### Event Handlers
- Prefix with `handle`: `handleClick`, `handleDrag`, `handlePortClick`
- Define in component body, pass as props to child components
- Use TypeScript event types: `MouseEvent`, `PointerEvent`, `KeyboardEvent`

### CSS
- Global styles in `src/App.css`
- No CSS modules or CSS-in-JS
- Use BEM-like naming for clarity
- Component-specific classes prefixed with component name

## File Organization

```
src/
├── components/
│   ├── Canvas.tsx         # Main canvas with pan/zoom, handles all interactions
│   ├── Toolbar.tsx        # Sidebar with add/delete/import/export controls
│   ├── Gate.tsx           # Renders logic gates (AND, OR, NOT, etc.)
│   ├── Switch.tsx         # Renders input switches
│   ├── Light.tsx          # Renders output lights
│   └── Wire.tsx           # Renders wires and wire preview
├── store/
│   └── circuitStore.ts    # Central state store and all mutations
├── types/
│   └── circuit.ts         # All TypeScript type definitions
├── utils/
│   └── helpers.ts         # Utility functions (ID generation, etc.)
├── App.tsx                # Root component
├── App.css                # Global styles
└── index.tsx              # Entry point
```

## Common Tasks

### Adding a New Gate Type
1. Add gate type to `GateType` union in `src/types/circuit.ts`
2. Add evaluation logic in `evaluateGate()` in `src/store/circuitStore.ts`
3. Add to `gateTypes` array in `src/components/Toolbar.tsx`
4. Add CSS styling in `src/App.css` (`.gate-NEWTYPE`)

### Adding a New Node Type
1. Define interface in `src/types/circuit.ts` (extend `BaseNode`)
2. Add to `CircuitNode` union type
3. Create factory function in `src/store/circuitStore.ts` (e.g., `createNewNode`)
4. Create component in `src/components/NewNode.tsx`
5. Update rendering logic in `src/components/Canvas.tsx`
6. Update validation in `importCircuit()` if needed

### Modifying Circuit State
- Always use store methods (don't mutate state directly)
- Call `propagateSignals()` after changes that affect signal flow
- Use `produce()` from solid-js/store for complex updates

### Working with Canvas Coordinates
- Canvas uses SVG with pan/zoom transforms
- Transform applied as: `translate(pan.x, pan.y) scale(zoom)`
- Convert screen coords to SVG coords using `getSvgPoint()`
- Port positions calculated dynamically in `getPortPosition()`

## Import/Export

### Export Format
```json
{
  "version": "1.0",
  "circuit": {
    "nodes": [...],
    "wires": [...]
  }
}
```

### Import Validation
- Validates JSON structure and required fields
- Checks node types and port existence
- Verifies wire connections reference valid nodes/ports
- Returns `{ success: boolean, error?: string }`

## Touch/Mobile Support

- Uses PointerEvents (not TouchEvents) for universal support
- Tracks active pointers by ID for multi-touch gestures
- Two-finger gesture → pan + pinch-to-zoom
- One-finger gesture → drag components
- Prevents conflicts between dragging and panning

## Testing Approach

- No formal tests currently
- Manual testing workflow:
  1. Add components of each type
  2. Connect with wires
  3. Toggle switches and verify lights
  4. Test export/import
  5. Test touch gestures on mobile
  6. Test keyboard shortcuts (Delete, Escape)

## Best Practices

1. **Reactivity**: Let SolidJS handle reactivity - avoid manual DOM manipulation
2. **Immutability**: Use store methods for all state changes
3. **Type Safety**: Leverage TypeScript - no type assertions unless necessary
4. **Simplicity**: Keep components focused and simple
5. **Performance**: Minimize re-renders by using fine-grained reactivity
6. **Accessibility**: Components are visual - consider adding ARIA labels in future

## Common Pitfalls

- Don't forget to call `propagateSignals()` after circuit changes
- Remember coordinate transforms when working with canvas positions
- Ensure wire connections go from output → input (not input → output)
- Don't allow multiple wires to the same input port
- Handle edge cases in signal propagation (disconnected nodes, cycles)

## Future Enhancements

Potential areas for improvement:
- Undo/redo functionality
- Component labeling/naming
- Multi-select and bulk operations
- Circuit templates library
- Subcircuits/hierarchical design
- Truth table generation
- Timing diagrams
- Mobile-optimized toolbar
- Accessibility improvements
- Unit tests with Vitest
